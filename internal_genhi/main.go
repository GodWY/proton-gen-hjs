package internal_genhi

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"regexp"
	"strings"
	"unicode"
	"unicode/utf8"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"

	"google.golang.org/protobuf/types/pluginpb"
)

// SupportedFeatures reports the set of supported protobuf language features.
var SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)

// GenerateFile generates the contents of a .pb.go file.
func GenerateFile(gen *protogen.Plugin, file *protogen.File) *protogen.GeneratedFile {
	return generateFile(gen, file, false)
}

func genImport(gen *protogen.Plugin, g *protogen.GeneratedFile, f *fileInfo, imp protoreflect.FileImport) {
	impFile, ok := gen.FilesByPath[imp.Path()]
	if !ok {
		return
	}
	if impFile.GoImportPath == f.GoImportPath {
		// Don't generate imports or aliases for types in the same Go package.
		return
	}
	// Generate imports for all non-weak dependencies, even if they are not
	// referenced, because other code and tools depend on having the
	// full transitive closure of protocol buffer types in the binary.
	if !imp.IsWeak {
		g.Import(impFile.GoImportPath)
	}
	if !imp.IsPublic {
		return
	}

	// Generate public imports by generating the imported file, parsing it,
	// and extracting every symbol that should receive a forwarding declaration.
	impGen := GenerateFile(gen, impFile)
	impGen.Skip()
	b, err := impGen.Content()
	if err != nil {
		gen.Error(err)
		return
	}
	fset := token.NewFileSet()
	astFile, err := parser.ParseFile(fset, "", b, parser.ParseComments)
	if err != nil {
		gen.Error(err)
		return
	}
	genForward := func(tok token.Token, name string, expr ast.Expr) {
		// Don't import unexported symbols.
		r, _ := utf8.DecodeRuneInString(name)
		if !unicode.IsUpper(r) {
			return
		}
		// Don't import the FileDescriptor.
		if name == impFile.GoDescriptorIdent.GoName {
			return
		}
		// Don't import decls referencing a symbol defined in another package.
		// i.e., don't import decls which are themselves public imports:
		//
		//	type T = somepackage.T
		if _, ok := expr.(*ast.SelectorExpr); ok {
			return
		}
		g.P(tok, " ", name, " = ", impFile.GoImportPath.Ident(name))
	}
	g.P("// Symbols defined in public import of ", imp.Path(), ".")
	g.P()
	for _, decl := range astFile.Decls {
		switch decl := decl.(type) {
		case *ast.GenDecl:
			for _, spec := range decl.Specs {
				switch spec := spec.(type) {
				case *ast.TypeSpec:
					genForward(decl.Tok, spec.Name.Name, spec.Type)
				case *ast.ValueSpec:
					for i, name := range spec.Names {
						var expr ast.Expr
						if i < len(spec.Values) {
							expr = spec.Values[i]
						}
						genForward(decl.Tok, name.Name, expr)
					}
				case *ast.ImportSpec:
				default:
					panic(fmt.Sprintf("can't generate forward for spec type %T", spec))
				}
			}
		}
	}
	g.P()
}

// generateFile generates a _http.pb.go file containing kratos errors definitions.
func generateFile(gen *protogen.Plugin, file *protogen.File, omitempty bool) *protogen.GeneratedFile {
	if len(file.Services) == 0 {
		return nil
	}
	//filename := file.GeneratedFilenamePrefix + ".pb.go"
	//g := gen.NewGeneratedFile(filename, file.GoImportPath)
	//f := newFileInfo(file)
	//g.P("// Code generated by protoc-gen-js. DO NOT EDIT.")
	//g.P("// versions:", version.String())
	//for i, imps := 0, f.Desc.Imports(); i < imps.Len(); i++ {
	//	genImport(gen, g, f, imps.Get(i))
	//}
	//g.P()

	generateFileContent(gen, file, nil, omitempty)
	return nil
}

// generateFileContent generates the kratos errors definitions, excluding the package statement.
func generateFileContent(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile, omitempty bool) {
	if len(file.Services) == 0 {
		return
	}
	//g.P("// This is a compile-time assertion to ensure that this generated file")
	//g.P("// is compatible with the ts package it is being compiled against.")
	//data := parseGenFile(file)
	tt := new(TsTemplate)
	for _, v := range file.Services {
		tt.FilName = toLowerCamelCase(v.GoName) + "_" + string(file.GoPackageName)
		group := ApiGroup(v)
		fds := make([]*FuncDesc, 0, len(v.Methods))
		for _, vm := range v.Methods {
			fd := &FuncDesc{}
			fcom := &Comment{}
			var pd []*ParamDesc
			fd.FuncName = toLowerCamelCase(vm.GoName)
			fd.Path, fd.Method = GetMethodPath(group, vm)
			input := vm.Input
			outPut := vm.Output
			pd = GetInput(input)
			// 添加请求参数以及其描述信息
			fcom.FuncComment = GenFuncDesc(vm)
			fcom.Params = pd
			fcom.Response = GetInput(outPut)
			fd.Comment = fcom
			fds = append(fds, fd)

		}
		tt.FD = fds
		Exec(tt)
	}

}

// RestfulAPI 定义方法
type RestfulAPI struct {
	// 请求方法。 目前支持GET，POST，ANY
	RequestMethod string
	// 自定义的路径
	Url string
	// api方法
	Method       string
	body         string
	responseBody string
}

// genImportService 读取本服务导入的包
func genImportService(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile, omitempty bool) []string {
	// 读取导入的包
	importPath := []string{}
	for _, v := range file.Services {
		// 读取注释
		serviceComments := string(v.Comments.Leading)
		if serviceComments == "" {
			continue
		}
		var commentsArr = []string{}
		if strings.Contains(serviceComments, "@") {
			// middleWares = parserComment(serviceComments)
			commentsArr = strings.Split(serviceComments, "@")
		}
		for _, c := range commentsArr {
			c = strings.TrimSpace(c)
			c = strings.TrimLeft(c, "\r\n")
			c = strings.TrimRight(c, "\r\n")
			if strings.HasPrefix(c, "import") {
				importPath = append(importPath, strings.Split(c, ":")[1])
				continue
			}
		}
	}
	return importPath
}

const deprecationComment = "// Deprecated: Do not use."

// ServiceInfo 服务的基本信息，包括组路由，中间件
type ServiceInfo struct {
	// 根路由
	ProjectUri string
	// 中间件
	MiddleWire string
	// 导包路径
	ImportPath []string
	Method     string
}

// parserComment 转化注释为字符串
func parserComment(comment []string) *ServiceInfo {
	si := &ServiceInfo{}
	var middleware string
	for _, c := range comment {
		c = strings.TrimSpace(c)
		c = strings.TrimLeft(c, "\r\n")
		c = strings.TrimRight(c, "\r\n")
		if strings.HasPrefix(c, "root") {
			si.ProjectUri = strings.Split(c, ":")[1]
			continue
		}
		if strings.HasPrefix(c, "middle") {
			middleware = strings.Split(c, ":")[1]
		}
		if strings.HasPrefix(c, "method") {
			si.Method = strings.Split(c, ":")[1]
		}
	}
	si.MiddleWire = middleware
	return si

}

// httpMethod 获取gin的方法，目前只支持GET，POST
func httpMethod(method string) (string, bool) {
	method = strings.ToLower(method)
	switch method {
	case "get":
		return method, false
	case "post":
		return method, true
	default:
		return "", false
	}
	return "", false
}

type serviceDesc struct {
	// group service的名称
	group string
	// children 子路径
	children string
	ics      []*IFace
}

type IFace struct {
	path     string
	method   string
	funcName string
}

func parseGenFile(file *protogen.File) []*serviceDesc {
	sds := make([]*serviceDesc, 0, len(file.Services))
	for _, srv := range file.Services {
		var group string
		sd := &serviceDesc{}
		group = "api/" + strings.ToLower(srv.GoName)
		comments := srv.Comments.Leading.String()
		ca := strings.Split(comments, "@")
		descInfo := parserComment(ca)
		if descInfo.ProjectUri != "" {
			group = descInfo.ProjectUri
		}
		if strings.HasSuffix(group, "/") {
			group = group + "v1"
		} else {
			group = group + "/v1"
		}
		for _, m := range srv.Methods {
			mcomments := m.Comments.Leading.String()
			mca := strings.Split(mcomments, "@")
			mdescInfo := parserComment(mca)
			prefix := m.GoName[0:1]
			last := m.GoName[1:]
			x := fmt.Sprintf("%s%v", strings.ToLower(prefix), last)
			ic := &IFace{
				path:     group + "/" + x,
				method:   mdescInfo.Method,
				funcName: m.GoName,
			}
			sd.ics = append(sd.ics, ic)
		}
		sds = append(sds, sd)
	}
	return sds
}
func toLowerCamelCase(goName string) string {
	prefix := goName[0:1]
	last := goName[1:]
	x := fmt.Sprintf("%s%v", strings.ToLower(prefix), last)
	return x
}

func GetMethodPath(group string, m *protogen.Method) (path, method string) {
	mcomments := m.Comments.Leading.String()
	mca := strings.Split(mcomments, "@")
	mdescInfo := parserComment(mca)
	x := toLowerCamelCase(m.GoName)
	path = fmt.Sprintf("%s/%s", group, x)
	method = mdescInfo.Method
	if method == "" {
		method = "GET"
	}
	return
}

// GetInput 获取请求参数的字段详细信息
func GetInput(input *protogen.Message) []*ParamDesc {
	pds := make([]*ParamDesc, 0, len(input.Messages))
	for _, fields := range input.Fields {
		notes := fields.Comments.Leading.String()
		note := strings.Split(notes, "//")
		var fn string
		for _, v := range note {
			vv := strings.TrimSpace(v)
			if strings.HasPrefix(vv, "@note:") {
				fn = v
				break
			}
		}
		if len(fn) == 0 {
			fn = "@note:暂无注释，请联系后端开发索要注释。"
		}
		fnote := strings.Split(fn, "@note:")[1]
		f := func(s string) string {
			var re = regexp.MustCompile("([a-z0-9])([A-Z])")
			snake := re.ReplaceAllString(s, "${1}_${2}")
			return strings.ToLower(snake)
		}
		pd := &ParamDesc{
			Typ:  ToJsNumber(fields.Desc.Kind()),
			Key:  f(fields.Desc.JSONName()),
			Desc: strings.TrimSpace(fnote),
		}
		pds = append(pds, pd)
	}
	return pds
}

func ToJsNumber(k protoreflect.Kind) string {
	switch k {
	case protoreflect.BoolKind:
		return "bool"
	case protoreflect.EnumKind:
		return "enum"
	case protoreflect.Int32Kind:
		return "number"
	case protoreflect.Sint32Kind:
		return "number"
	case protoreflect.Uint32Kind:
		return "number"
	case protoreflect.Int64Kind:
		return "number"
	case protoreflect.Sint64Kind:
		return "number"
	case protoreflect.Uint64Kind:
		return "number"
	case protoreflect.Sfixed32Kind:
		return "sfixed32"
	case protoreflect.Fixed32Kind:
		return "fixed32"
	case protoreflect.FloatKind:
		return "number"
	case protoreflect.Sfixed64Kind:
		return "sfixed64"
	case protoreflect.Fixed64Kind:
		return "fixed64"
	case protoreflect.DoubleKind:
		return "number"
	case protoreflect.StringKind:
		return "string"
	case protoreflect.BytesKind:
		return "bytes"
	case protoreflect.MessageKind:
		return "Object"
	case protoreflect.GroupKind:
		return "group"
	default:
		return fmt.Sprintf("<unknown:%d>", k)
	}
}

func ApiGroup(srv *protogen.Service) string {
	group := "api/" + strings.ToLower(srv.GoName)
	comments := srv.Comments.Leading.String()
	ca := strings.Split(comments, "@")
	descInfo := parserComment(ca)
	if descInfo.ProjectUri != "" {
		group = descInfo.ProjectUri
	}
	group = group + "/" + toLowerCamelCase(srv.GoName)
	if strings.HasSuffix(group, "/") {
		group = group + "v1"
	} else {
		group = group + "/v1"
	}
	return group
}

// GenFuncDesc 获取rpc每个接口的描述
func GenFuncDesc(method *protogen.Method) string {
	comments := method.Comments.Leading.String()
	ca := strings.Split(comments, "@")
	for _, c := range ca {
		c = strings.TrimSpace(c)
		c = strings.TrimLeft(c, "\r\n")
		c = strings.TrimRight(c, "\r\n")
		if strings.HasPrefix(c, "doc") {
			return strings.Split(c, ":")[1]
		}
	}
	return "暂无描述"
}
